---
title: "@State란"
date: 2024-02-31 12:00:00 +0900
categories: [개념, SwiftUI]
tags: []
---


# SwiftUI의 `@State` – 뷰의 로컬 상태 관리 속성 래퍼

## 개요

`@State`는 SwiftUI에서 **뷰 내부에서 상태를 관리하는 가장 기본적인 속성 래퍼**다.
뷰가 소유하고 직접 변경할 수 있는 값이며, 상태가 변하면 뷰가 자동으로 다시 그려진다.



## 왜 필요한가?

SwiftUI는 선언형 UI 프레임워크로, 상태가 변경되면 UI를 업데이트한다.
하지만 뷰 내부에서 변경 가능한 상태를 저장할 변수가 필요하다.
이때 `@State`를 사용해 상태 변수를 선언한다.


## 내부 동작 원리
- @State 값은 외부 저장소에 보관하고 SwiftUI가 참조/관리
- 뷰 자체를 바꾸는게 아니라 SwiftUI 상태 저장소의 값을 바꾸는 것
- 값이 바뀌면 SwiftUI가 자동으로 body를 다시 그려줌

### 외부 저장소
- @State 프로퍼티는 사실 뷰 구조체의 프로퍼티가 아님
- @State 변수를 별도의 메모리 영역에 보관함
- 뷰 구조체 (`ContentView`)는 매번 새로 생성되고 버려지지만, `@State`값은 내부 참조 타입의 컨테이너 안에 보관되어 유지됨

**동작 과정**
1. 뷰가 처음 생성될 때
- `@State var isActive = false` -> SwiftUI가 상태 저장소 컨테이너를 만들고 `false` 저장

2. 뷰가 새로 그려질 때 (body 호출하여 업데이트가 필요한 UI 확인)
- SwiftUI는 이 저장소에서 값을 읽어서 `isActive`에 바인딩

3. 값이 바뀔 때 (`isActive.toggle()`)
- 구조체의 값이 변하는게 아니라 저장소 안 값이 변함
- SwiftUI가 값 변경을 감지 -> `body`를 호출해서 뷰를 리렌더링















## 사용법

```swift
struct CounterView: View {
    @State private var count: Int = 0  // 상태 변수 선언

    var body: some View {
        VStack {
            Text("Count: \(count)")
            Button("Increase") {
                count += 1  // 상태 변경
            }
        }
    }
}
```

* `@State` 변수는 **뷰가 소유하는 로컬 상태**다.
* 변수 값이 변경되면 뷰가 다시 렌더링된다.
* `private`으로 선언하는 것이 일반적이다.

---

## 특징

* **로컬 상태 관리:** 뷰 내에서만 상태가 유효하며, 외부 뷰에서는 직접 접근 불가.
* **값 타입 기반:** 상태 변경 시 뷰가 다시 그려진다.
* **바인딩 가능:** 다른 뷰에 상태를 전달할 때 `$`를 붙여 바인딩으로 넘길 수 있다.

---

## 실전 예시

```swift
struct ToggleView: View {
    @State private var isOn: Bool = false

    var body: some View {
        Toggle("Switch", isOn: $isOn)
            .padding()
    }
}
```

* `Toggle`은 바인딩을 요구하므로 `@State` 앞에 `$`를 붙여 바인딩을 넘긴다.
* 토글 스위치를 켜고 끌 때 `isOn` 상태가 변경되며 뷰가 갱신된다.

---

## 정리

* `@State`는 **뷰가 직접 소유하고 관리하는 상태 변수 선언에 사용**한다.
* 상태가 변하면 SwiftUI가 자동으로 뷰를 갱신해 UI 일관성을 유지한다.
* 복잡한 상태 관리가 필요하면 `@Binding`, `@StateObject`, `@ObservedObject`와 함께 사용한다.

